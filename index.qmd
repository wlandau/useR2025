---
format:
   revealjs:
     css: style.css
     incremental: true
     slide-number: true
     footer: "&copy; 2025 Eli Lilly and Company"
     view-distance: 100
     mobile-view-distance: 100
extensions:
  - jmbuhr/quarto-qrcode
---

##

```{r, include = FALSE, echo = FALSE}
set.seed(0)
suppressPackageStartupMessages({
  library(targets)
})
knitr::opts_chunk$set(
  cache = FALSE,
  comment = "#>",
  echo = TRUE,
  eval = FALSE,
  fig.width = 10, 
  fig.height = 5
)
```

<style>
.reveal .tiny {
  display: inline-block;
  font-size: 0.5em;
  line-height: 1.0em;
  vertical-align: top;
}
.reveal .medium {
  display: inline-block;
  font-size: 0.75em;
  line-height: 1.5em;
  vertical-align: top;
}
pre code {
  overflow-x: hidden !important;
}
</style>

<center>
<br>
<h3>Powerful simulation pipelines with {targets}</h3>
<img src="./images/targets.png" height="400px">
<br>
<h4>Will Landau</h4>
</center>

::: {.notes}
One of the things we've seen at this conference is that we're using R more and more in the life sciences.
For industrial biomedical research.
I want to share with you, not only a tool but a whole paradigm, that's really helped me and my colleagues for many years in this space.
:::


## Modeling and simulation {style="font-size: 1.1em"}

![](./images/compiling.png){fig-align="center"}

<span style="font-size: 0.5em">Credit: <a href="https://xkcd.com/303/">https://xkcd.com/303/</a>, Randal Munroe</span>

:::{.notes}
But first, let's revisit one of our favorite webcomics.
This comic is famous and forever memorialized in the history of the internet because reveals such a relatable unspoken reality in software engineering.
You write a program, but then before you use it, you have to let it compile.
And while it compiles, there's nothing for you to do.
You just have to sit there and let the computer do its thing.

And I know, not all of us are software engineers.
We're statisticians, mathematicians, ecologists, economists, geneticists, etc.
But this... this is us... all the time.

Only instead of "my code is compiling", it's usually: "my model is fitting", or "my simulation is running".
And instead of slacking off and having sword fights in the office...
:::

## Disruption and repetition

![](./images/sisyphus.svg){fig-align="center"}

:::{.notes}
...we're disrupted.
And delayed.
It's painful.
And just because a model or a simulation runs once, doesn't mean it's usable.
We repeat ourselves until we get it right.

Now I'm going to share with you when we most often find ourselves here.
And what my colleagues and I do about it.
:::


# Clinical trial simulation

## Drug development

<center>
<img src="./images/process.png">
</center>


## Clinical trials

<center>
<img src="./images/clinical.png">
</center>

## Responsibilities

<center>
<img src="./images/responsibility.png">
</center>

## Clinical trial simulation: goals

<center>
<img src="./images/goals.jpg" height="300px">
</center>

. . .

Quantify decision-making ability.

. . .

Compare alternative designs.




## Clinical trial simulation: steps

<center>
<img src="./images/steps.jpg" height="300px">
</center>

1. Simulate virtual patients.
1. Analyze with models.
1. Repeat thousands of times.

## Clinical trial simulation: challenges

<center>
<img src="./images/challenges.jpg" height="300px">
</center>

. . .

Complicated R code.

. . .

Long execution times.

. . .

Frequent changes.

# Example trial

## Hypothetical trial

<center>
<img src="./images/stethoscope.jpg" height="300px">
</center>

. . .

Extremely rare and severe autoimmune liver disease.

. . .

Phase 2A study, first look at efficacy.

. . .

Double blind: novel therapy vs standard of care.

. . .

Randomize up to 100 patients (1:1).

## Bayesian joint model {.nonincremental}

:::{.fragment}

#### Longitudinal endpoint: log bilirubin

$$
\begin{aligned}
\color{orange}{\eta_i(t)} = x_i(t) \beta + b_i
\end{aligned}
$$

:::

. . .

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $\color{orange}{\eta_i(t)}$: expected log bilirubin for patient $i$ at time $t$. 

:::{.fragment}

#### Survival endpoint: years without liver transplant or death

$$
\begin{aligned}
h_i(t) = h_0(t, \lambda) \exp \left (\color{orange}{\eta_i(t)} \alpha + d_i \color{blue}{\theta} \right )
\end{aligned}
$$

:::

. . .

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $d_i$: 1 for treatment, 0 for control.

. . .

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $\color{blue}{\theta}$: log hazard ratio of treatment vs control.

## Decision rules {.nonincremental}


$$
\begin{aligned}
g(y) = \text{P}(\exp(\color{blue}{\theta}) < 0.75 \ | \ y)
\end{aligned}
$$

:::{.fragment}

#### Declare efficacy if:

$$
\begin{aligned}
g(y) > 0.8
\end{aligned}
$$
:::

:::{.fragment}

#### Declare futility if:

$$
\begin{aligned}
g(y) < 0.4
\end{aligned}
$$

:::

## Clinical trial design

<center>
<img src="./images/stethoscope.jpg" height="300px">
</center>

. . .

10-year accrual period.

. . .

Futility interim at $n$ events (liver transplant or death).

. . .

**Goal: simulate to propose a suitable $n$**.

## Simulate futility

![](./images/bayes.png)

. . .

Simulate 10000 futile trials for $n = 40, 50, 60, 70$.

. . .

A fixed hazard ratio of 1 would be unrealistic.

. . .

Instead, draw from a distribution that captures futility.

. . .

Use the posterior distribution from a historical trial.

## Historical futility data

<center>
<img src="./images/data.jpg" height="300px">
</center>

. . .

Datasets `pbc` and `pbcseq` from the `survival` package.

. . .

Indication: primary biliary cholangitis (PBC).

. . .

Mayo Clinic trial of D-penicillamine vs placebo.

. . .

D-penicillamine did not improve survival.

## Estimated hazard ratio

<center>
<img src="./images/hazard_ratio.png">
</center>

# R code

## Functions {.nonincremental}

$$
\Huge
{\color{blue}{y}} = {\color{purple}{f}}({\color{teal}{x}})
$$
<br>

> Everything that exists in an object. <br>
> Everything that happens is a function call.
>
> <br>
> — John Chambers

## Top-level R functions

$$
\Huge
{\color{blue}{y}} = {\color{purple}{f}}({\color{teal}{x}})
$$

<br>

Function | Description
---|---
`draw_hazard_ratios()` | From historical model.
`trial()` | Simulate one trial rep.
`plot_results()` | Visualize results.

## Example simulation replication

<center>
<img src="./images/r.png" height="200px">
</center>
<br>

```{r}
trial(hazard_ratio = 0.5, events = 50)
#> # A tibble: 1 × 4
#>   events efficacy enrolled years
#>    <dbl>    <dbl>    <dbl> <dbl>
#> 1     50    0.998       83  8.52
```

## Example simulation replication

<center>
<img src="./images/r.png" height="200px">
</center>
<br>

```{r}
trial(hazard_ratio = 1.2, events = 50)
#> # A tibble: 1 × 4
#>   events efficacy enrolled years
#>    <dbl>    <dbl>    <dbl> <dbl>
#> 1     50   0.0324       72  7.35
```


## All together, informally

:::{.nonincremental}

Step 1: draw historical hazard ratios.

```{r}
hazard_ratios <- draw_hazard_ratios(10000)
```

:::{.fragment}

Step 2: run simulations.

```{r}
results <- hazard_ratios |>
  expand_grid(events = c(40, 50, 60, 70)) |>
  pmap(trial) |>
  list_rbind()
```

:::

:::{.fragment}

Step 3: plot results.

```{r}
plot_results(results)
```

:::

:::

# Workflow challenges

## Implementing the joint model

```{r}
rstanarm::stan_jm(
  formulaLong = log_bilirubin ~
    study_arm + albumin + years_measured +
    (1 | patient_id),
  formulaEvent = Surv(years_survived, event) ~
    study_arm,
  time_var = "years_measured",
  dataLong = data_longitudinal,
  dataEvent = data_survival
)
```

## Backend: Stan

<br>

![](./images/stan.png){fig-align="center"}

## Computational demands of Stan/HMC

![](./images/hmc.png){fig-align="center"}

. . .

HMC = Hamiltonian Monte Carlo.

. . .

Physics simulation samples from the posterior distribution.


## Computation time

```{r}
system.time(draw_hazard_ratios())
#>    user  system elapsed 
#> 658.306   2.424 177.468 
```

<br>

. . . 

```{r}
system.time(trial(1, events = 70))
#>    user  system elapsed 
#> 115.568   0.726  32.261 
```

. . . 

<br>

<span style="font-weight: bold; color: brown; font-size:1.25em">
32 seconds x 10000 reps x 4 scenarios $>$ 2 weeks!
</span>

## Numbered notebooks?

<center>
<img src="./images/notebook-start.png">
</center>

## What about data?

<center>
<img src="./images/notebook-data.png">
</center>

## Complexity?

<center>
<img src="./images/notebook-change.png">
</center>

## Keeping results up to date?

<center>
<img src="./images/notebook-rerun.png">
</center>

# Pipelines

## What is a pipeline?

<center>
<img src="./images/graph-final.png" height = "300px">
</center>

.  . .

A pipeline is a formal group of tasks.

. . .

Each task has dependencies, a command, and output.

. . .


A task can only modify its own output.

. . .

A task cannot eventually depend on itself.

## Pipeline tools

<br>

<center>
<img src="./images/infographic.png" height = "300px">
</center>

Examples: Make, Airflow, Nextflow, Prefect, and `targets`.

## targets: a pipeline tool for R

<center>
<img src="./images/logo-tweet.png" height="300px">
</center>

. . .

Retains the comfort of your local R session.

. . .

Focuses on your functions, not your scripts.

. . .

Integrates with Quarto.

. . .

Runs distributed computing.

# Trial simulation pipeline

## Project-oriented workflow

<br>

```{r}
fs::dir_tree()
#> _targets.R
#> R
#> ├── draw_hazard_ratios.R
#> ├── plot_results.R
#> ├── trial.R
#> └── utils.R
```

. . .

`R/` scripts contain functions.

. . .

`_targets.R` defines the pipeline.

## Define the pipeline in _targets.R

```{r}
library(targets)

tar_option_set(...)

tar_source()

list(
  tar_target(hazard_ratios, ...),
  tar_target(trials, ...),
  ...
)
```

## Options and parallel computing

```{r}
library(crew.cluster)

controller <- crew_controller_sge(
  workers = 500,
  cores = 4,
  seconds_idle = 120
)

tar_option_set(
  packages = c("rstanarm", ...),
  controller = controller
)
```

## Inputs

```{r}
tar_target(
  name = events,
  command = c(40, 50, 60, 70)
)
```

. . .

<br>

Equivalent to:

```{r}
function() {
  result <- c(40, 50, 60, 70)
  saveRDS(result, "_targets/objects/events")
}
```

## Inputs

```{r}
tar_target(
  name = hazard_ratios,
  command = draw_hazard_ratios(10000)
)
```

<br>

. . .

Equivalent to:

```{r}
function(draw_hazard_ratios) {
  result <- draw_hazard_ratios(10000)
  saveRDS(result, "_targets/objects/hazard...")
}
```

## Simulations

```{r}
tar_target(
  name = trials,
  command = trial(hazard_ratios, events),
  pattern = cross(hazard_ratios, events)
)
```

. . .

<br>

For each combination of hazard ratio and event threshold:

```{r}
function(trial, hazard_ratio, event) {
  result <- trial(hazard_ratio, event)
  saveRDS(result, "_targets/objects/trials...")
}
```

## Results

```{r}
tar_target(
  name = plot,
  command = plot_results(trials)
)
```

<br>

. . .

Equivalent to:

```{r}
function(plot_results, trials) {
  result <- plot_results(trials)
  saveRDS(result, "_targets/objects/events")
}
```

## Results

```{r}
tarchetypes::tar_quarto(
  name = quarto,
  path = "results.qmd"
)
```

<br>

. . .

Equivalent to:

```{r}
function(path, plot) {
  quarto::quarto_render(path)
  c("results.html", path)
}
```

## Quarto report

<center>
<img src="./images/quarto-source.png" height="550px">
</center>

## Graph visualization

```{r}
tar_visnetwork(targets_only = TRUE)
```

<br>

<center>
<img src="./images/graph-outdated.png">
</center>

## Implicit dependencies

<center>
<img src="./images/graph-dependencies.png">
</center>

```{r}
tar_target(
  name = plot,
  command = plot_results(trials)
)
```

# Running the pipeline

## Run the pipeline

```{r}
tar_make(as_job = TRUE)
```

<center>
<img src="./images/workbench.png">
</center>

## Auto-scaled distributed computing

![](./images/Slide10.png){fig-align="center"}

## Auto-scaled distributed computing

![](./images/Slide11.png){fig-align="center"}

## Auto-scaled distributed computing

![](./images/Slide12.png){fig-align="center"}

## Auto-scaled distributed computing

![](./images/Slide13.png){fig-align="center"}

## Auto-scaled distributed computing

![](./images/Slide14.png){fig-align="center"}

## Auto-scaled distributed computing

![](./images/Slide15.png){fig-align="center"}

## Track progress

<br>

```{r}
tar_progress_summary()[, 1:3]
#> # A tibble: 1 × 3
#>   skipped dispatched completed
#>     <int>      <int>     <int>
#> 1       0        500     12613
```

## Track progress

<br>

```{r}
tar_visnetwork(targets_only = TRUE)
```

<center>
<img src="./images/graph-dispatched.png">
</center>

## Monitor workers

```{r}
library(crew.cluster)
monitor <- crew_monitor_sge()

monitor$jobs()[, c(1, 3, 4, 9)]
#> # A tibble: 2 × 4
#>   job_number name   state slots
#>   <chr>      <chr>  <chr> <chr>
#> 1 131853812  crew-… r     4    
#> 2 131853813  crew-… r     4
```

## Simulation results

```{r}
tar_read(trials, branches = seq_len(8))
#> # A tibble: 10 × 4
#>    events efficacy enrolled years
#>     <dbl>    <dbl>    <dbl> <dbl>
#>  1     40   0.055        58  6.31
#>  2     50   0.0685       77  7.99
#>  3     60   0.0602       81  7.93
#>  4     70   0.153        93  9.01
#>  5     40   0.220        65  6.03
#>  6     50   0.479        73  6.43
#>  7     60   0.918        87  8.91
#>  8     70   0.832        89  8.99
```

## Plot

```{r}
tar_read(plot)
```

<center>
<img src="./images/plot.png">
</center>

## Quarto report

::::{.columns}

:::{.column width="50%"}

<center>
<img src="./images/quarto-source.png">
</center>

:::

:::{.column width="50%"}

<center>
<img src="./images/quarto.png">
</center>

:::

::::

## Add a new target

```{r}
tar_target(
  name = years,
  command = plot_years(trials)
)
```

<center>
<img src="./images/graph-years.png">
</center>

## Skip up-to-date targets

<br>

```{r}
tar_make()
#> ...
#> ✔ skipping targets (40002 so far)...
#> ▶ dispatched target years
```

## Years until interim

```{r}
tar_read(years)
```

<center>
<img src="./images/years.png">
</center>

## Change an event threshold

```{r}
tar_target(
  name = events,
  command = c(40, 50, 60, 75)
)
```

<center>
<img src="./images/graph-change-event-threshold.png">
</center>

## Change an upstream function

<center>
<img src="./images/graph-change-function.png">
</center>

## Up-to-date pipeline

```{r}
tar_outdated()
#> character(0)
```

<br>

```{r}
tar_visnetwork(targets_only = TRUE)
```

<center>
<img src="./images/graph-uptodate.png">
</center>

## Conclusions

<center>
<img src="./images/plot-large-font.png" height = "400px">
</center>

. . .

Interim at 40 events looks promising.

. . .

Need to simulate full design with interims and final analysis

# Recap


## Benefits of pipeline tools

<br>

::::{.columns}

:::{.column width="50%"}

<center>
<img src="./images/targets.png" height = "400px">
</center>

:::

:::{.column width="50%"}

<center>
<div style="font-size: 2em;">
1. Time savings
2. Reproducibility
3. Peace of mind
</div>
</center>

:::

::::

## Slides: [wlandau.github.io/useR2025](https://wlandau.github.io/useR2025)

<center>
{{< qrcode https://wlandau.github.io/useR2025 width=500 height=500 >}}
</center>

## Links to resources

::: {.nonincremental}

<br>

[`targets` documentation](https://docs.ropensci.org/targets)

<br>

[Clinical trial simulation pipeline](https://github.com/wlandau/targets-example-liver)

:::

## Sources {.tiny}

:::{.nonincremental}

* Brilleman, S. L., M. J. Crowther, M. Moreno-Betancur, J. Buros Novik, and R. Wolfe. 2018. "Joint Longitudinal and Time-to-Event Models via Stan." In StanCon 2018. https://github.com/stan-dev/stancon_talks/.
* Dickson, E. R., T. R. Fleming, R. H. Wiesner, W. P. Baldus, C. R. Fleming, J. Ludwig, and J. T. McCall. 1985. "Trial of Penicillamine in Advanced Primary Biliary Cirrhosis." New England Journal of Medicine 312 (16): 1011–15. https://doi.org/10.1056/NEJM198504183121602.
* Goodrich, B., J. Gabry, I. Ali, and S. L. Brilleman. 2024. "rstanarm: Bayesian applied regression modeling via Stan." https://mc-stan.org/rstanarm.
* Landau, W. M., Kunzmann, K., Sidi, Y., Stock, C. 2024. "brms.mmrm: Bayesian MMRMs using 'brms'". R package version 1.1.1, <https://openpharma.github.io/brms.mmrm/>.
* Landau, W. M. 2021. "The targets R package: a dynamic Make-like function-oriented pipeline toolkit for reproducibility and high-performance computing." Journal of Open Source Software 6 (57): 2959. https://doi.org/10.21105/joss.02959.
* Lawrence, G. A., M. E. Boye, M. J. Crowther, J. G. Ibrahim, G. Quartey, S. Micallef, and F. Y. Bois. 2016. "Joint modeling of survival and longitudinal non-survival data: current methods and issues. Report of the DIA Bayesian joint modeling working group." Statistics in Medicine 34 (14): 2181–95. https://doi.org/10.1002/sim.6141.
* Modrák, M., Moon, A. H., Kim, S., Bürkner, P., Huurre, N., Faltejsková, K., Gelman, A., Vehtari, A. 2023. "Simulation-Based Calibration Checking for Bayesian Computation: The Choice of Test Quantities Shapes Sensitivity". Bayesian Analysis. <https://doi.org/10.1214/23-BA1404>.
* Therneau, T. M., and P. M. Grambsch. 2000. Modeling Survival Data: Extending the Cox Model. New York: Springer.
:::


## Image credit {.tiny}

:::{.nonincremental}

* <https://xkcd.com/303/>
* <https://unsplash.com/photos/brown-and-gray-stones-on-white-surface-hUjSO5dZA_E>
* <https://unsplash.com/photos/person-stepping-on-blue-stairs-7_kRuX1hSXM>
* <https://unsplash.com/photos/red-white-and-black-round-wheel-RjqCk9MqhNg>
* <https://unsplash.com/photos/matrix-movie-still-iar-afB0QQw>
* <https://unsplash.com/photos/black-and-gray-stethoscope-yo01Z-9HQAw>
* <https://unsplash.com/photos/white-printing-paper-with-numbers-Wpnoqo2plFA>
* <https://unsplash.com/photos/woman-in-brown-sweater-covering-her-face-with-her-hand-_sh9vkVbVgo>
* <https://unsplash.com/license>
* `images/hmc.png`: Prof. David Kahle, Baylor University.

:::
